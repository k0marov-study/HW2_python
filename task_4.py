"""
Очевидно, что нужно проходиться по последовательности, 
сохраняя нынешнюю длину монотонной последовательности и лучший результат. 
Дальше нужно проверять, подходить ли каждый следующий элемент к этой монотонной последовательности, или нет. 
Если он подходит, то увеличиваем длину. 
Если нет, то значит эта последовательность закончилась на предыдущем элементе. 
Тогда перезаписываем значение лучшего результата (если это нужно) и устанавливаем нынешнюю длину на 2 (нынешний элемент и предыдущий). 

Чтобы на каждой итерации понимать контекст нынешней последовательности, достаточно двух переменных: в одной нужно сохранять предыдущий элемент, а в другой, к примеру, - True, если последовательность возрастающая, и False, если она убывающая. 

Дальше нужно отдельно разбирать случаи для начала новой подпоследовательности (когда предыдущий элемент None или вторая переменная None). 

Также отдельно нужно рассматривать случаи, когда два одинаковых элемента идут подряд. Во первых, это означает обязательное завершение нынешней последовательности, а во вторых - при начале следующей нельзя брать нынешние 2 элемента, а можно только 1. И, соответственно, is_increasing нужно устанавливать как None, так как в подпоследовательности пока только 1 и неизвестно, будет она возрастающая или убывающая.
"""
best = 0 
curr = 0 

prev = None
is_increasing = None 
a = int(input()) 
while a != 0: 
    any_fits = prev is None or is_increasing is None
    if a != prev and (any_fits or (a > prev) == is_increasing): 
        is_increasing = a > prev if prev is not None else None
        curr += 1
    else: 
        is_increasing = not is_increasing if a != prev else None
        best = curr if curr > best else best 
        curr = 2 if a != prev else 1 
    prev = a 
    a = int(input())

best = curr if curr > best else best 

print(best)

